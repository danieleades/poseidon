#![feature(impl_trait_in_assoc_type)]
use chrono::{DateTime, Utc};
use std::{cmp::Ordering, collections::{BTreeMap, BTreeSet}};
use uuid::Uuid;

mod probability;

mod transmission_history;
use transmission_history::TransmissionHistory;

mod coordinate;
pub use coordinate::Coordinate;

type NodeId = Uuid;

/// A time-series collection of 3D coordinates.
///
/// Supports efficient filtering and searching by time.
#[derive(Debug, Clone, Default)]
pub struct Positions {
    transmission_history: TransmissionHistory,
    data: BTreeSet<Datum>,
}

/// A single data point in the time-series.
#[derive(Debug, Clone, PartialEq)]
pub struct Datum {
    pub id: Uuid,
    pub timestamp: DateTime<Utc>,
    pub coordinate: Coordinate,
}

impl Ord for Datum {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.timestamp.cmp(&other.timestamp).then_with(|| self.id.cmp(&other.id))
    }
}

impl PartialOrd for Datum {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Eq for Datum {}

impl Positions {
    /// Adds a new position to the collection.
    ///
    /// TODO: This currently assumes that the timestamp is later than any previously added timestamp (without checking).
    pub fn add(&mut self, timestamp: DateTime<Utc>, position: Coordinate) -> Uuid {
        let id = Uuid::new_v4();
        self.data.insert(Datum {
            id,
            timestamp,
            coordinate: position,
        });
        id
    }

    /// Filters positions by a time range.
    pub fn filter_by_time(
        &self,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
    ) -> impl Iterator<Item = &Datum> {
        self.data
            .iter()
            .filter(move |datum| start <= datum.timestamp && datum.timestamp <= end)
    }

    /// Returns the most novel coordinates for a given recipient.
    ///
    /// The most novel coordinates are those that are furthest from the polyline generated by the already-transmitted (100% probability) coordinates, weighted by the probability that the recipient has not received them already.
    ///
    /// This method returns at most `n_max` results
    #[must_use]
    pub fn most_novel_coordinates(&self, recipient: &NodeId, n_max: usize) -> Vec<&Datum> {
        // First consider the first and last coordinates.
        let ((start, start_novelty), (end, end_novelty)) =
            self.start_and_end_point_novelty(recipient);
        let mut results = Results::new(n_max);
        results.insert(start, start_novelty);
        results.insert(end, end_novelty);

        // Then recursively search the rest of the coordinates.
        let segment = self.data.iter().collect::<Vec<_>>();
        let results = self.most_novel_coordinates_in_segment(recipient, &segment, results);

        // Sort the results by novelty score, then return the top `n_max` results.
        results.into_iter().collect()
    }

    /// Returns the novelty scores for the start and end coordinates.
    ///
    /// The novelty score is the distance between them, scaled by the probability that the recipient has not received them yet.
    fn start_and_end_point_novelty(&self, recipient: &NodeId) -> ((&Datum, f64), (&Datum, f64)) {
        let start = self.data.first().unwrap();
        let end = self.data.last().unwrap();
        let distance = start.coordinate.distance(&end.coordinate);
        let start_novelty = distance
            * self
                .transmission_history
                .probability_recipient_has_datum(recipient, &start.id)
                .complement();
        let end_novelty = distance
            * self
                .transmission_history
                .probability_recipient_has_datum(recipient, &end.id)
                .complement();
        ((start, start_novelty), (end, end_novelty))
    }
    /// Returns the most novel datum for a given recipient in a given segment and it's associated 'novelty score'.
    ///
    /// The novelty score is the perpendicular distance from the segment defined by the start and end of the segment to the coordinate, weighted by the probability that the recipient has not received the coordinate yet.
    ///
    /// This method is recursive. It returns the most novel datum for the segment, and is used recursively to search the left and right subsegments on either side of the most novel datum.
    fn most_novel_coordinates_in_segment<'a>(
        &'a self,
        recipient: &NodeId,
        segment: &[&'a Datum],
        mut results: Results<'a>,
    ) -> Results<'a> {
        // Base case: if the segment is empty or has only one or two data points, return an empty vector
        if segment.len() <= 2 {
            return results;
        }

        // Get the start and end coordinates of the segment
        let start = &segment[0].coordinate;
        let end = &segment[segment.len() - 1].coordinate;

        // Find the most novel datum in the segment, excluding the first and last points
        let most_novel = segment[1..segment.len() - 1]
            .iter()
            .enumerate()
            .map(|(i, datum)| {
                let distance = distance_from_line(start, end, &datum.coordinate);
                let probability = self
                    .transmission_history
                    .probability_recipient_has_datum(recipient, &datum.id);
                let novelty_score = distance * probability.complement();
                (i + 1, datum, novelty_score)
            })
            .max_by(|a, b| a.2.partial_cmp(&b.2).unwrap_or(std::cmp::Ordering::Equal))
            .expect("Segment must have at least one element");

        // Recursively search the left and right subsegments
        let left_segment = &segment[..=most_novel.0];
        let right_segment = &segment[most_novel.0..];

        results.insert(most_novel.1, most_novel.2);
        let results = self.most_novel_coordinates_in_segment(recipient, left_segment, results);
        let results = self.most_novel_coordinates_in_segment(recipient, right_segment, results);
        results
    }
}

/// Calculates the perpendicular distance from a coordinate to a line defined by two coordinates.
fn distance_from_line(start: &Coordinate, end: &Coordinate, coordinate: &Coordinate) -> f64 {
    // Vector from start to end
    let line_vector = Coordinate {
        x: end.x - start.x,
        y: end.y - start.y,
        z: end.z - start.z,
    };

    // Vector from start to the coordinate
    let point_vector = Coordinate {
        x: coordinate.x - start.x,
        y: coordinate.y - start.y,
        z: coordinate.z - start.z,
    };

    // Calculate the cross product
    let cross_product = Coordinate {
        x: line_vector.y * point_vector.z - line_vector.z * point_vector.y,
        y: line_vector.z * point_vector.x - line_vector.x * point_vector.z,
        z: line_vector.x * point_vector.y - line_vector.y * point_vector.x,
    };

    // Calculate the magnitude of the cross product
    let cross_product_magnitude =
        (cross_product.x.powi(2) + cross_product.y.powi(2) + cross_product.z.powi(2)).sqrt();

    // Calculate the magnitude of the line vector
    let line_magnitude =
        (line_vector.x.powi(2) + line_vector.y.powi(2) + line_vector.z.powi(2)).sqrt();

    // The perpendicular distance is the magnitude of the cross product divided by the magnitude of the line vector
    cross_product_magnitude / line_magnitude
}

#[derive(Debug)]
struct Novelty {
    score: f64,
    id: Uuid,
}

impl Ord for Novelty {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        match other.score.partial_cmp(&self.score) {
            None | Some(Ordering::Equal) => other.id.cmp(&self.id),
            Some(ordering) => ordering,
        }
    }
}

impl PartialOrd for Novelty {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for Novelty {
    fn eq(&self, other: &Self) -> bool {
        self.score.eq(&other.score) && self.id.eq(&other.id)
    }
}

impl Eq for Novelty {}

#[derive(Debug)]
struct Results<'a> {
    n_max: usize,
    data: BTreeMap<Novelty, &'a Datum>,
}

impl<'a> Results<'a> {
    /// Creates a new `Results` struct with a maximum of `n_max` results.
    const fn new(n_max: usize) -> Self {
        Self {
            n_max,
            data: BTreeMap::new(),
        }
    }

    /// Inserts a new datum into the results, keeping only the `n_max` most novel results.
    fn insert(&mut self, datum: &'a Datum, novelty_score: f64) {
        if self.data.len() < self.n_max {
            let novelty = Novelty {
                score: novelty_score,
                id: datum.id,
            };
            self.data.insert(novelty, datum);
        } else if novelty_score > self.min_novelty() {
            self.data.pop_last();
            let novelty = Novelty {
                score: novelty_score,
                id: datum.id,
            };
            self.data.insert(novelty, datum);
        }
    }

    /// Returns the novelty score of the least novel coordinate in the results or 0.0 if the results are empty.
    fn min_novelty(&self) -> f64 {
        self.data.keys().next_back().map_or(0.0, |k| k.score)
    }
}

impl<'a> IntoIterator for Results<'a> {
    type Item = &'a Datum;
    type IntoIter = impl Iterator<Item = Self::Item>;

    /// Returns an iterator over the results.
    ///
    /// Ordering: most novel to least novel
    fn into_iter(self) -> Self::IntoIter {
        self.data.into_values()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use float_cmp::assert_approx_eq;

    #[test]
    fn test_distance_from_line() {
        let start = Coordinate::new(0.0, 0.0, 0.0);
        let end = Coordinate::new(1.0, 1.0, 1.0);
        let coordinate = Coordinate::new(0.5, 0.5, 0.5);
        assert_approx_eq!(f64, distance_from_line(&start, &end, &coordinate), 0.0);
    }

    #[test]
    fn test_distance_from_line2() {
        let start = Coordinate::new(0.0, 0.0, 0.0);
        let end = Coordinate::new(4.0, 0.0, 0.0);
        let coordinate = Coordinate::new(2.0, 2.0, 0.0);
        assert_approx_eq!(f64, distance_from_line(&start, &end, &coordinate), 2.0);
    }

    #[test]
    fn test_most_novel_coordinates() {
        // Coordinate arrangement:
        //
        //     y
        //     ^
        //   2 |           * (2,2)
        //     |
        //   1 |     * (1,1)     * (3,1)
        //     |
        //   0 * (0,0)                 * (4,0)
        //     +-----|-----|-----|-----|---->
        //     0     1     2     3     4     x

        let mut positions = Positions::default();
        let id0 = positions.add(Utc::now(), Coordinate::new(0.0, 0.0, 0.0));
        let _id1 = positions.add(Utc::now(), Coordinate::new(1.0, 1.0, 0.0));
        let id2 = positions.add(Utc::now(), Coordinate::new(2.0, 2.0, 0.0));
        let _id3 = positions.add(Utc::now(), Coordinate::new(3.0, 1.0, 0.0));
        let id4 = positions.add(Utc::now(), Coordinate::new(4.0, 0.0, 0.0));

        let most_novel = positions.most_novel_coordinates(&NodeId::new_v4(), 3);
        assert_eq!(most_novel.len(), 3);
        // Assert that the most novel positions contain the ids of points id0, id2, and id4
        let expected_ids = vec![id0, id2, id4];
        for expected_id in expected_ids {
            assert!(
                most_novel.iter().any(|datum| datum.id == expected_id),
                "Expected ID {expected_id} not found in most novel coordinates"
            );
        }
    }
}
