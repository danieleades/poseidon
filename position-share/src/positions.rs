use chrono::{DateTime, Utc};
use search_strategy::SearchStrategy;
use std::collections::BTreeSet;
use uuid::Uuid;

pub mod geometric_novelty;
pub mod search_strategy;

use crate::coordinate::Coordinate;
use crate::transmission_history::TransmissionHistory;

type NodeId = Uuid;

/// A time-series collection of 3D coordinates.
///
/// Supports efficient filtering and searching by time.
#[derive(Debug, Clone, Default)]
pub struct Positions {
    transmission_history: TransmissionHistory,
    data: BTreeSet<Datum>,
}

impl Positions {
    /// Adds a new position to the collection.
    ///
    /// TODO: This currently assumes that the timestamp is later than any previously added timestamp (without checking).
    pub fn add(&mut self, timestamp: DateTime<Utc>, position: Coordinate) -> Uuid {
        let id = Uuid::new_v4();
        self.data.insert(Datum {
            id,
            timestamp,
            coordinate: position,
        });
        id
    }

    /// Filters positions by a time range.
    pub fn filter_by_time(
        &self,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
    ) -> impl Iterator<Item = &Datum> {
        self.data
            .iter()
            .filter(move |datum| start <= datum.timestamp && datum.timestamp <= end)
    }

    /// Returns the most novel coordinates for a given recipient.
    ///
    /// The most novel coordinates are those that are furthest from the polyline generated by the already-transmitted (100% probability) coordinates, weighted by the probability that the recipient has not received them already.
    ///
    /// This method returns at most `n_max` results
    #[must_use]
    pub fn most_novel_coordinates(
        &self,
        strategy: &impl SearchStrategy,
        recipient: &NodeId,
        n_max: usize,
    ) -> Vec<&Datum> {
        strategy.search(
            &self.transmission_history,
            &self.data.iter().collect::<Vec<_>>(),
            n_max,
            recipient,
        )
    }
}

/// A single data point in the time-series.
#[derive(Debug, Clone, PartialEq)]
pub struct Datum {
    pub id: Uuid,
    pub timestamp: DateTime<Utc>,
    pub coordinate: Coordinate,
}

impl Ord for Datum {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.timestamp
            .cmp(&other.timestamp)
            .then_with(|| self.id.cmp(&other.id))
    }
}

impl PartialOrd for Datum {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Eq for Datum {}

#[cfg(test)]
mod tests {
    use super::*;
    use geometric_novelty::rdp;
    use search_strategy::Search;

    #[test]
    fn test_most_novel_coordinates() {
        // Coordinate arrangement:
        //
        //     y
        //     ^
        //   2 |           * (2,2)
        //     |
        //   1 |     * (1,1)     * (3,1)
        //     |
        //   0 * (0,0)                 * (4,0)
        //     +-----|-----|-----|-----|---->
        //     0     1     2     3     4     x

        let mut positions = Positions::default();
        let id0 = positions.add(Utc::now(), Coordinate::new(0.0, 0.0, 0.0));
        let _id1 = positions.add(Utc::now(), Coordinate::new(1.0, 1.0, 0.0));
        let id2 = positions.add(Utc::now(), Coordinate::new(2.0, 2.0, 0.0));
        let _id3 = positions.add(Utc::now(), Coordinate::new(3.0, 1.0, 0.0));
        let id4 = positions.add(Utc::now(), Coordinate::new(4.0, 0.0, 0.0));

        let search_strategy = Search::new(rdp, None);

        let most_novel = positions.most_novel_coordinates(&search_strategy, &NodeId::new_v4(), 3);

        // Assert that we got the correct number of results
        assert_eq!(most_novel.len(), 3);

        // Assert that the most novel positions contain the ids of points id0, id2, and id4
        for expected_id in [id0, id2, id4] {
            assert!(
                most_novel.iter().any(|datum| datum.id == expected_id),
                "Expected ID {expected_id} not found in most novel coordinates"
            );
        }
    }
}
